#!/usr/bin/env python3
"""
Test Generator Module for py-armodel

This module handles generation of pytest test cases for AUTOSAR classes.
"""

from pathlib import Path
from typing import Any, Dict, List

# Import pluralization helper from code_generator
from . import code_generator


def generate_test_case(
    class_name: str,
    class_info: Dict[str, Any],
    package_path: str,
    module_path: str,
    requirements_dir: Path,
    project_root: Path
) -> str:
    """Generate pytest test case code for a generated class.

    Args:
        class_name: Name of the class
        class_info: Class information dictionary from requirements
        package_path: Full package path (e.g., 'M2::AUTOSARTemplates::...')
        module_path: Python module path for import
        requirements_dir: Path to requirements directory
        project_root: Root directory of the project

    Returns:
        Generated test code
    """
    from . import type_resolver

    is_abstract = class_info.get('is_abstract', False)
    attributes = class_info.get('attributes', {})
    parent = class_info.get('parent') or 'ARObject'
    has_short_name_init = type_resolver._has_short_name_in_init(class_info, requirements_dir)

    # Test file header
    test_code = f'''"""
Auto-generated test cases for {class_name}.
Generated by fix-package-implementation.py.
"""

import pytest

from {module_path} import {class_name}
from armodel import AUTOSAR


class Test{class_name}:
    """Test cases for {class_name} class."""

'''

    # Generate initialization test
    if is_abstract:
        test_code += _generate_abstract_instantiation_test(class_name, has_short_name_init)
    else:
        test_code += _generate_initialization_test(class_name, has_short_name_init)

    # Generate attribute tests (only for concrete classes)
    if not is_abstract:
        for attr_name, attr_info in attributes.items():
            attr_type = attr_info.get('type', 'Any')
            multiplicity = attr_info.get('multiplicity', '1')

            # Determine Python attribute name using helper function
            if code_generator._is_multiple_multiplicity(multiplicity):
                py_attr_name = code_generator._pluralize_attr_name(attr_name)
            else:
                py_attr_name = attr_name

            # Determine object instantiation pattern
            if has_short_name_init:
                obj_instantiation = f'        obj = {class_name}(ar_root, "test_{class_name.lower()}")'
                setup_code = '''        document = AUTOSAR.getInstance()
        ar_root = document.createARPackage("AUTOSAR")
'''
            else:
                obj_instantiation = f'        obj = {class_name}()'
                setup_code = ''

            if multiplicity == '*':
                test_code += _generate_list_attribute_tests(
                    class_name, attr_name, py_attr_name, attr_info, parent, setup_code, obj_instantiation, requirements_dir, project_root
                )
            else:
                test_code += _generate_single_attribute_tests(
                    class_name, attr_name, py_attr_name, setup_code, obj_instantiation
                )

    return test_code


def _generate_abstract_instantiation_test(class_name: str, has_short_name_init: bool) -> str:
    """Generate test for abstract class instantiation prevention.

    Args:
        class_name: Name of the abstract class
        has_short_name_init: Whether __init__ has (parent, short_name) signature

    Returns:
        Test method code
    """
    if has_short_name_init:
        return f'''
    def test_abstract_class_cannot_be_instantiated(self):
        """Test that {class_name} is abstract and cannot be instantiated directly."""
        document = AUTOSAR.getInstance()
        ar_root = document.createARPackage("AUTOSAR")

        with pytest.raises(TypeError) as err:
            obj = {class_name}(ar_root, "test_{class_name.lower()}")
        assert str(err.value) == "{class_name} is an abstract class."
'''
    else:
        return f'''
    def test_abstract_class_cannot_be_instantiated(self):
        """Test that {class_name} is abstract and cannot be instantiated directly."""
        with pytest.raises(TypeError) as err:
            obj = {class_name}()
        assert str(err.value) == "{class_name} is an abstract class."
'''


def _generate_initialization_test(class_name: str, has_short_name_init: bool) -> str:
    """Generate test for class initialization.

    Args:
        class_name: Name of the class
        has_short_name_init: Whether __init__ has (parent, short_name) signature

    Returns:
        Test method code
    """
    if has_short_name_init:
        return f'''
    def test_initialization(self):
        """Test initialization of {class_name} with proper attributes."""
        document = AUTOSAR.getInstance()
        ar_root = document.createARPackage("AUTOSAR")
        obj = {class_name}(ar_root, "test_{class_name.lower()}")

        assert obj.short_name == "test_{class_name.lower()}"
'''
    else:
        return f'''
    def test_initialization(self):
        """Test initialization of {class_name}."""
        obj = {class_name}()
        assert obj is not None
'''


def _generate_list_attribute_tests(
    class_name: str,
    attr_name: str,
    py_attr_name: str,
    attr_info: Dict[str, Any],
    parent: str,
    setup_code: str,
    obj_instantiation: str,
    requirements_dir: Path,
    project_root: Path
) -> str:
    """Generate tests for list-type attributes.

    Args:
        class_name: Name of the class
        attr_name: Original attribute name
        py_attr_name: Python attribute name (pluralized)
        attr_info: Attribute information dictionary
        parent: Parent class name
        setup_code: Setup code for AUTOSAR document
        obj_instantiation: Object instantiation code
        requirements_dir: Path to requirements directory
        project_root: Root directory of the project

    Returns:
        Test method code
    """
    from . import type_resolver

    # Compute singular form for create/add method names
    singular_attr = code_generator._singularize_attr_name(py_attr_name)
    singular_capitalized = singular_attr[0].upper() + singular_attr[1:]

    # Get the actual type to check if it's Any or will be downgraded to Any
    attr_type = attr_info.get('type', 'Any')
    is_ref = attr_info.get('is_ref', False)

    # Check if type exists in codebase or requirements
    # If not, it will be downgraded to Any and we should skip the add/create test
    type_exists = (
        attr_type == 'Any' or
        is_ref or
        type_resolver.find_type_in_codebase_cached(project_root, attr_type) is not None
    )

    # Check if we should skip the add/create test (when type doesn't exist or is Any)
    should_skip_add_test = not type_exists

    add_test = ''
    if not should_skip_add_test:
        add_test = f'''
    def test_add_{attr_name}(self):
        """Test adding/creating {attr_name}."""
{setup_code}{obj_instantiation}

        initial_count = len(obj.get{py_attr_name[0].upper()}{py_attr_name[1:]}())
        # Test uses create method for owned attributes, add method for references
        attr_kind = {repr(attr_info.get('kind', 'attribute'))}
        is_ref = {attr_info.get('is_ref', False)}
        should_use_create = (attr_kind == 'attribute' and not is_ref and {code_generator._should_have_create_methods(class_name, parent)})

        if should_use_create:
            # For create method, use singular form of attribute name
            result = obj.create{singular_capitalized}("test_value")
            assert result is not None
        else:
            # For add method, also use singular form of attribute name
            result = obj.add{singular_capitalized}(None)
            assert result == obj
        assert len(obj.get{py_attr_name[0].upper()}{py_attr_name[1:]}()) >= initial_count
'''

    return f'''
    def test_get_{attr_name}(self):
        """Test getting {attr_name} list."""
{setup_code}{obj_instantiation}

        result = obj.get{py_attr_name[0].upper()}{py_attr_name[1:]}()
        assert isinstance(result, list)

    def test_set_{attr_name}(self):
        """Test setting {attr_name} list."""
{setup_code}{obj_instantiation}

        test_value = []
        result = obj.set{py_attr_name[0].upper()}{py_attr_name[1:]}(test_value)

        assert result == obj
        assert obj.get{py_attr_name[0].upper()}{py_attr_name[1:]}() == test_value
{add_test}'''


def _generate_single_attribute_tests(
    class_name: str,
    attr_name: str,
    py_attr_name: str,
    setup_code: str,
    obj_instantiation: str
) -> str:
    """Generate tests for single-value attributes.

    Args:
        class_name: Name of the class
        attr_name: Original attribute name
        py_attr_name: Python attribute name
        setup_code: Setup code for AUTOSAR document
        obj_instantiation: Object instantiation code

    Returns:
        Test method code
    """
    return f'''
    def test_get_{attr_name}(self):
        """Test getting {attr_name}."""
{setup_code}{obj_instantiation}

        result = obj.get{py_attr_name[0].upper()}{py_attr_name[1:]}()
        assert result == None

    def test_set_{attr_name}(self):
        """Test setting {attr_name}."""
{setup_code}{obj_instantiation}

        test_value = None
        result = obj.set{py_attr_name[0].upper()}{py_attr_name[1:]}(test_value)

        assert result == obj
        assert obj.get{py_attr_name[0].upper()}{py_attr_name[1:]}() == test_value
'''


def print_generation_report(unresolved_types: Dict[str, List[tuple]], errors: List[str], warnings: List[str]) -> None:
    """Print the generation report with all issues.

    Args:
        unresolved_types: Dictionary of class_name -> [(type_name, context), ...]
        errors: List of error messages
        warnings: List of warning messages
    """
    if not unresolved_types and not errors and not warnings:
        return

    print("\n" + "=" * 60)
    print("Generation Report")
    print("=" * 60)

    if unresolved_types:
        print("\n⚠️  Unresolved Types (downgraded to Any):")
        for class_name, types in unresolved_types.items():
            print(f"\n  {class_name}:")
            for type_name, context in types:
                print(f"    - {type_name} ({context})")

    if errors:
        print("\n❌ Errors:")
        for error in errors:
            print(f"  - {error}")

    if warnings:
        print("\n⚠️  Warnings:")
        for warning in warnings:
            print(f"  - {warning}")
