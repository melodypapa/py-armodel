from abc import ABC, abstractmethod
from typing import List, Optional, Dict, Any

class EcuInstance(FibexElement):
    """
    ECUInstances are used to define the ECUs used in the topology. The type of
    the ECU is defined by a reference to an ECU specified with the ECU resource
    description.
    
    Package: M2::AUTOSARTemplates::SystemTemplate::Fibex::FibexCore::CoreTopology::EcuInstance
    
    Sources:
      - AUTOSAR_CP_TPS_DiagnosticExtractTemplate.pdf (Page 312, Classic Platform
      R23-11)
      - AUTOSAR_CP_TPS_SoftwareComponentTemplate.pdf (Page 985, Classic Platform
      R23-11)
      - AUTOSAR_CP_TPS_SystemTemplate.pdf (Page 50, Classic Platform R23-11)
      - AUTOSAR_FO_TPS_SecurityExtractTemplate.pdf (Page 59, Foundation R23-11)
    """
    def __init__(self):
        super().__init__()

    # ===== Pythonic properties (CODING_RULE_V2_00016) =====
        # With this reference it is possible to identify which ISignal are applicable
                # for which Communication level ISignalIPduGroups shall be referenced by If an
                # ISignalIPduGroup contains other these contained ISignalIPdu not be referenced
                # by the EcuInstance.
        # are associated to an Ecu the top level ISignalIPduGroup.
        # 719 Document ID 673: AUTOSAR_CP_TPS_DiagnosticExtractTemplate Template
                # R23-11.
        self._associatedCom: List[RefType] = []

    @property
    def associated_com(self) -> List[RefType]:
        """Get associatedCom (Pythonic accessor)."""
        return self._associatedCom
        # With this reference it is possible to identify which
                # ConsumedProvidedServiceInstanceGroups are for which ECUInstance.
        # atpSplitable; atpVariation Group Tags:.
        self._associated: List["ConsumedProvided"] = []

    @property
    def associated(self) -> List["ConsumedProvided"]:
        """Get associated (Pythonic accessor)."""
        return self._associated
        # With this reference it is possible to identify which PduR Groups are
        # applicable for which Communication.
        self._associatedPdur: List[RefType] = []

    @property
    def associated_pdur(self) -> List[RefType]:
        """Get associatedPdur (Pythonic accessor)."""
        return self._associatedPdur
        # If this parameter is available and set to true, then all channels will be
                # woken up as soon as at least channel wakeup occurs.
        # If PNCs are configured, then will be requested upon a channel wakeup.
        self._channel: Optional["Boolean"] = None

    @property
    def channel(self) -> Optional["Boolean"]:
        """Get channel (Pythonic accessor)."""
        return self._channel

    @channel.setter
    def channel(self, value: Optional["Boolean"]) -> None:
        """
        Set channel with validation.
        
        Args:
            value: The channel to set
        
        Raises:
            TypeError: If value type is incorrect
        """
        if value is None:
            self._channel = None
            return

        if not isinstance(value, Boolean):
            raise TypeError(
                f"channel must be Boolean or None, got {type(value).__name__}"
            )
        self._channel = value
        # Restriction of the Client Identifier for this Ecu to an of numerical values.
        # The Client Identifier of handle is generated by the client RTE for
                # communication.
        self._clientIdRange: Optional["ClientIdRange"] = None

    @property
    def client_id_range(self) -> Optional["ClientIdRange"]:
        """Get clientIdRange (Pythonic accessor)."""
        return self._clientIdRange

    @client_id_range.setter
    def client_id_range(self, value: Optional["ClientIdRange"]) -> None:
        """
        Set clientIdRange with validation.
        
        Args:
            value: The clientIdRange to set
        
        Raises:
            TypeError: If value type is incorrect
        """
        if value is None:
            self._clientIdRange = None
            return

        if not isinstance(value, ClientIdRange):
            raise TypeError(
                f"clientIdRange must be ClientIdRange or None, got {type(value).__name__}"
            )
        self._clientIdRange = value
        # The period between successive calls to Com_Main of the AUTOSAR COM module in
        # seconds.
        self._com: Optional["TimeValue"] = None

    @property
    def com(self) -> Optional["TimeValue"]:
        """Get com (Pythonic accessor)."""
        return self._com

    @com.setter
    def com(self, value: Optional["TimeValue"]) -> None:
        """
        Set com with validation.
        
        Args:
            value: The com to set
        
        Raises:
            TypeError: If value type is incorrect
        """
        if value is None:
            self._com = None
            return

        if not isinstance(value, TimeValue):
            raise TypeError(
                f"com must be TimeValue or None, got {type(value).__name__}"
            )
        self._com = value
        # Enables for the Com module of this EcuInstance the delay time monitoring for
        # cyclic and repeated (TransmissionModeTiming has cyclic or
        # eventControlledTiming with numberOf 0).
        self._comEnable: Optional["Boolean"] = None

    @property
    def com_enable(self) -> Optional["Boolean"]:
        """Get comEnable (Pythonic accessor)."""
        return self._comEnable

    @com_enable.setter
    def com_enable(self, value: Optional["Boolean"]) -> None:
        """
        Set comEnable with validation.
        
        Args:
            value: The comEnable to set
        
        Raises:
            TypeError: If value type is incorrect
        """
        if value is None:
            self._comEnable = None
            return

        if not isinstance(value, Boolean):
            raise TypeError(
                f"comEnable must be Boolean or None, got {type(value).__name__}"
            )
        self._comEnable = value
        # CommunicationControllers of the ECU.
        # atpSplitable; atpVariation.
        self._commController: List["Communication"] = []

    @property
    def comm_controller(self) -> List["Communication"]:
        """Get commController (Pythonic accessor)."""
        return self._commController
        # All channels controlled by a single controller.
        # atpSplitable; atpVariation.
        self._connector: List["Communication"] = []

    @property
    def connector(self) -> List["Communication"]:
        """Get connector (Pythonic accessor)."""
        return self._connector
        # Describes the Dlt configuration on this EcuInstance.
        self._dltConfig: Optional["DltConfig"] = None

    @property
    def dlt_config(self) -> Optional["DltConfig"]:
        """Get dltConfig (Pythonic accessor)."""
        return self._dltConfig

    @dlt_config.setter
    def dlt_config(self, value: Optional["DltConfig"]) -> None:
        """
        Set dltConfig with validation.
        
        Args:
            value: The dltConfig to set
        
        Raises:
            TypeError: If value type is incorrect
        """
        if value is None:
            self._dltConfig = None
            return

        if not isinstance(value, DltConfig):
            raise TypeError(
                f"dltConfig must be DltConfig or None, got {type(value).__name__}"
            )
        self._dltConfig = value
        # DoIp configuration on this EcuInstance.
        self._doIpConfig: Optional["DoIpConfig"] = None

    @property
    def do_ip_config(self) -> Optional["DoIpConfig"]:
        """Get doIpConfig (Pythonic accessor)."""
        return self._doIpConfig

    @do_ip_config.setter
    def do_ip_config(self, value: Optional["DoIpConfig"]) -> None:
        """
        Set doIpConfig with validation.
        
        Args:
            value: The doIpConfig to set
        
        Raises:
            TypeError: If value type is incorrect
        """
        if value is None:
            self._doIpConfig = None
            return

        if not isinstance(value, DoIpConfig):
            raise TypeError(
                f"doIpConfig must be DoIpConfig or None, got {type(value).__name__}"
            )
        self._doIpConfig = value
        # Reference to OsTaskProxies assigned to the Ecu 719 Document ID 673:
        # AUTOSAR_CP_TPS_DiagnosticExtractTemplate Template R23-11.
        self._ecuTaskProxy: List["OsTaskProxy"] = []

    @property
    def ecu_task_proxy(self) -> List["OsTaskProxy"]:
        """Get ecuTaskProxy (Pythonic accessor)."""
        return self._ecuTaskProxy
        # Defines whether the derivation of SwitchPortGroups on VLAN and/or
                # CouplingPort.
        # pncMapping shall be for this EcuInstance.
        # If not defined the not be done.
        self._ethSwitchPort: Optional["Boolean"] = None

    @property
    def eth_switch_port(self) -> Optional["Boolean"]:
        """Get ethSwitchPort (Pythonic accessor)."""
        return self._ethSwitchPort

    @eth_switch_port.setter
    def eth_switch_port(self, value: Optional["Boolean"]) -> None:
        """
        Set ethSwitchPort with validation.
        
        Args:
            value: The ethSwitchPort to set
        
        Raises:
            TypeError: If value type is incorrect
        """
        if value is None:
            self._ethSwitchPort = None
            return

        if not isinstance(value, Boolean):
            raise TypeError(
                f"ethSwitchPort must be Boolean or None, got {type(value).__name__}"
            )
        self._ethSwitchPort = value
        # Firewall rules defined in the context of an EcuInstance.
        self._firewallRule: List["StateDependentFirewall"] = []

    @property
    def firewall_rule(self) -> List["StateDependentFirewall"]:
        """Get firewallRule (Pythonic accessor)."""
        return self._firewallRule
        # Optional definition of Partitions within an Ecu.
        self._partition: List["EcuPartition"] = []

    @property
    def partition(self) -> List["EcuPartition"]:
        """Get partition (Pythonic accessor)."""
        return self._partition
        # Defines if this EcuInstance shall request Nm on all its have Nm variant set
        # to FULL a PNC is requested.
        self._pncNmRequest: Optional["Boolean"] = None

    @property
    def pnc_nm_request(self) -> Optional["Boolean"]:
        """Get pncNmRequest (Pythonic accessor)."""
        return self._pncNmRequest

    @pnc_nm_request.setter
    def pnc_nm_request(self, value: Optional["Boolean"]) -> None:
        """
        Set pncNmRequest with validation.
        
        Args:
            value: The pncNmRequest to set
        
        Raises:
            TypeError: If value type is incorrect
        """
        if value is None:
            self._pncNmRequest = None
            return

        if not isinstance(value, Boolean):
            raise TypeError(
                f"pncNmRequest must be Boolean or None, got {type(value).__name__}"
            )
        self._pncNmRequest = value
        # Time in seconds the PNC state machine shall wait in.
        self._pncPrepare: Optional["TimeValue"] = None

    @property
    def pnc_prepare(self) -> Optional["TimeValue"]:
        """Get pncPrepare (Pythonic accessor)."""
        return self._pncPrepare

    @pnc_prepare.setter
    def pnc_prepare(self, value: Optional["TimeValue"]) -> None:
        """
        Set pncPrepare with validation.
        
        Args:
            value: The pncPrepare to set
        
        Raises:
            TypeError: If value type is incorrect
        """
        if value is None:
            self._pncPrepare = None
            return

        if not isinstance(value, TimeValue):
            raise TypeError(
                f"pncPrepare must be TimeValue or None, got {type(value).__name__}"
            )
        self._pncPrepare = value
        # If this parameter is available and set to true then all PNCs will be woken up
                # as soon as a channel occurs.
        # This is ensured by adding all PNCs to all sources during upstream mapping.
        self._pnc: Optional["Boolean"] = None

    @property
    def pnc(self) -> Optional["Boolean"]:
        """Get pnc (Pythonic accessor)."""
        return self._pnc

    @pnc.setter
    def pnc(self, value: Optional["Boolean"]) -> None:
        """
        Set pnc with validation.
        
        Args:
            value: The pnc to set
        
        Raises:
            TypeError: If value type is incorrect
        """
        if value is None:
            self._pnc = None
            return

        if not isinstance(value, Boolean):
            raise TypeError(
                f"pnc must be Boolean or None, got {type(value).__name__}"
            )
        self._pnc = value
        # Specifies the runtime of the reset timer in seconds.
        # This is valid for the reset of PN requests in the EIRA the ERA.
        self._pnResetTime: Optional["TimeValue"] = None

    @property
    def pn_reset_time(self) -> Optional["TimeValue"]:
        """Get pnResetTime (Pythonic accessor)."""
        return self._pnResetTime

    @pn_reset_time.setter
    def pn_reset_time(self, value: Optional["TimeValue"]) -> None:
        """
        Set pnResetTime with validation.
        
        Args:
            value: The pnResetTime to set
        
        Raises:
            TypeError: If value type is incorrect
        """
        if value is None:
            self._pnResetTime = None
            return

        if not isinstance(value, TimeValue):
            raise TypeError(
                f"pnResetTime must be TimeValue or None, got {type(value).__name__}"
            )
        self._pnResetTime = value
        # Specifies whether the ECU instance may be put to a "low mode" sleep mode is
        # supported sleep mode is not supported flag may only be set to "true" if the
        # feature is both hardware and basic software.
        self._sleepMode: Optional["Boolean"] = None

    @property
    def sleep_mode(self) -> Optional["Boolean"]:
        """Get sleepMode (Pythonic accessor)."""
        return self._sleepMode

    @sleep_mode.setter
    def sleep_mode(self, value: Optional["Boolean"]) -> None:
        """
        Set sleepMode with validation.
        
        Args:
            value: The sleepMode to set
        
        Raises:
            TypeError: If value type is incorrect
        """
        if value is None:
            self._sleepMode = None
            return

        if not isinstance(value, Boolean):
            raise TypeError(
                f"sleepMode must be Boolean or None, got {type(value).__name__}"
            )
        self._sleepMode = value
        # EcuInstance specific ICMP (Internet Control Message.
        self._tcpIpIcmpProps: Optional["EthTcpIpIcmpProps"] = None

    @property
    def tcp_ip_icmp_props(self) -> Optional["EthTcpIpIcmpProps"]:
        """Get tcpIpIcmpProps (Pythonic accessor)."""
        return self._tcpIpIcmpProps

    @tcp_ip_icmp_props.setter
    def tcp_ip_icmp_props(self, value: Optional["EthTcpIpIcmpProps"]) -> None:
        """
        Set tcpIpIcmpProps with validation.
        
        Args:
            value: The tcpIpIcmpProps to set
        
        Raises:
            TypeError: If value type is incorrect
        """
        if value is None:
            self._tcpIpIcmpProps = None
            return

        if not isinstance(value, EthTcpIpIcmpProps):
            raise TypeError(
                f"tcpIpIcmpProps must be EthTcpIpIcmpProps or None, got {type(value).__name__}"
            )
        self._tcpIpIcmpProps = value
        # EcuInstance specific TcpIp Stack attributes.
        self._tcpIpProps: Optional["EthTcpIpProps"] = None

    @property
    def tcp_ip_props(self) -> Optional["EthTcpIpProps"]:
        """Get tcpIpProps (Pythonic accessor)."""
        return self._tcpIpProps

    @tcp_ip_props.setter
    def tcp_ip_props(self, value: Optional["EthTcpIpProps"]) -> None:
        """
        Set tcpIpProps with validation.
        
        Args:
            value: The tcpIpProps to set
        
        Raises:
            TypeError: If value type is incorrect
        """
        if value is None:
            self._tcpIpProps = None
            return

        if not isinstance(value, EthTcpIpProps):
            raise TypeError(
                f"tcpIpProps must be EthTcpIpProps or None, got {type(value).__name__}"
            )
        self._tcpIpProps = value
        # This attribute is used to control the existence of the V2X the given
        # EcuInstance.
        self._v2xSupported: Optional["V2xSupportEnum"] = None

    @property
    def v2x_supported(self) -> Optional["V2xSupportEnum"]:
        """Get v2xSupported (Pythonic accessor)."""
        return self._v2xSupported

    @v2x_supported.setter
    def v2x_supported(self, value: Optional["V2xSupportEnum"]) -> None:
        """
        Set v2xSupported with validation.
        
        Args:
            value: The v2xSupported to set
        
        Raises:
            TypeError: If value type is incorrect
        """
        if value is None:
            self._v2xSupported = None
            return

        if not isinstance(value, V2xSupportEnum):
            raise TypeError(
                f"v2xSupported must be V2xSupportEnum or None, got {type(value).__name__}"
            )
        self._v2xSupported = value
        # Driver support for wakeup over Bus.
        self._wakeUpOverBusSupported: Optional["Boolean"] = None

    @property
    def wake_up_over_bus_supported(self) -> Optional["Boolean"]:
        """Get wakeUpOverBusSupported (Pythonic accessor)."""
        return self._wakeUpOverBusSupported

    @wake_up_over_bus_supported.setter
    def wake_up_over_bus_supported(self, value: Optional["Boolean"]) -> None:
        """
        Set wakeUpOverBusSupported with validation.
        
        Args:
            value: The wakeUpOverBusSupported to set
        
        Raises:
            TypeError: If value type is incorrect
        """
        if value is None:
            self._wakeUpOverBusSupported = None
            return

        if not isinstance(value, Boolean):
            raise TypeError(
                f"wakeUpOverBusSupported must be Boolean or None, got {type(value).__name__}"
            )
        self._wakeUpOverBusSupported = value

    # ===== AUTOSAR-compatible methods (delegate to properties) =====

    def getAssociatedCom(self) -> List[RefType]:
        """
        AUTOSAR-compliant getter for associatedCom.
        
        Returns:
            The associatedCom value
        
        Note:
            Delegates to associated_com property (CODING_RULE_V2_00017)
        """
        return self.associated_com  # Delegates to property

    def getAssociated(self) -> List["ConsumedProvided"]:
        """
        AUTOSAR-compliant getter for associated.
        
        Returns:
            The associated value
        
        Note:
            Delegates to associated property (CODING_RULE_V2_00017)
        """
        return self.associated  # Delegates to property

    def getAssociatedPdur(self) -> List[RefType]:
        """
        AUTOSAR-compliant getter for associatedPdur.
        
        Returns:
            The associatedPdur value
        
        Note:
            Delegates to associated_pdur property (CODING_RULE_V2_00017)
        """
        return self.associated_pdur  # Delegates to property

    def getChannel(self) -> "Boolean":
        """
        AUTOSAR-compliant getter for channel.
        
        Returns:
            The channel value
        
        Note:
            Delegates to channel property (CODING_RULE_V2_00017)
        """
        return self.channel  # Delegates to property

    def setChannel(self, value: "Boolean") -> "EcuInstance":
        """
        AUTOSAR-compliant setter for channel with method chaining.
        
        Args:
            value: The channel to set
        
        Returns:
            self for method chaining
        
        Note:
            Delegates to channel property setter (gets validation automatically)
        """
        self.channel = value  # Delegates to property setter
        return self

    def getClientIdRange(self) -> "ClientIdRange":
        """
        AUTOSAR-compliant getter for clientIdRange.
        
        Returns:
            The clientIdRange value
        
        Note:
            Delegates to client_id_range property (CODING_RULE_V2_00017)
        """
        return self.client_id_range  # Delegates to property

    def setClientIdRange(self, value: "ClientIdRange") -> "EcuInstance":
        """
        AUTOSAR-compliant setter for clientIdRange with method chaining.
        
        Args:
            value: The clientIdRange to set
        
        Returns:
            self for method chaining
        
        Note:
            Delegates to client_id_range property setter (gets validation automatically)
        """
        self.client_id_range = value  # Delegates to property setter
        return self

    def getCom(self) -> "TimeValue":
        """
        AUTOSAR-compliant getter for com.
        
        Returns:
            The com value
        
        Note:
            Delegates to com property (CODING_RULE_V2_00017)
        """
        return self.com  # Delegates to property

    def setCom(self, value: "TimeValue") -> "EcuInstance":
        """
        AUTOSAR-compliant setter for com with method chaining.
        
        Args:
            value: The com to set
        
        Returns:
            self for method chaining
        
        Note:
            Delegates to com property setter (gets validation automatically)
        """
        self.com = value  # Delegates to property setter
        return self

    def getComEnable(self) -> "Boolean":
        """
        AUTOSAR-compliant getter for comEnable.
        
        Returns:
            The comEnable value
        
        Note:
            Delegates to com_enable property (CODING_RULE_V2_00017)
        """
        return self.com_enable  # Delegates to property

    def setComEnable(self, value: "Boolean") -> "EcuInstance":
        """
        AUTOSAR-compliant setter for comEnable with method chaining.
        
        Args:
            value: The comEnable to set
        
        Returns:
            self for method chaining
        
        Note:
            Delegates to com_enable property setter (gets validation automatically)
        """
        self.com_enable = value  # Delegates to property setter
        return self

    def getCommController(self) -> List["Communication"]:
        """
        AUTOSAR-compliant getter for commController.
        
        Returns:
            The commController value
        
        Note:
            Delegates to comm_controller property (CODING_RULE_V2_00017)
        """
        return self.comm_controller  # Delegates to property

    def getConnector(self) -> List["Communication"]:
        """
        AUTOSAR-compliant getter for connector.
        
        Returns:
            The connector value
        
        Note:
            Delegates to connector property (CODING_RULE_V2_00017)
        """
        return self.connector  # Delegates to property

    def getDltConfig(self) -> "DltConfig":
        """
        AUTOSAR-compliant getter for dltConfig.
        
        Returns:
            The dltConfig value
        
        Note:
            Delegates to dlt_config property (CODING_RULE_V2_00017)
        """
        return self.dlt_config  # Delegates to property

    def setDltConfig(self, value: "DltConfig") -> "EcuInstance":
        """
        AUTOSAR-compliant setter for dltConfig with method chaining.
        
        Args:
            value: The dltConfig to set
        
        Returns:
            self for method chaining
        
        Note:
            Delegates to dlt_config property setter (gets validation automatically)
        """
        self.dlt_config = value  # Delegates to property setter
        return self

    def getDoIpConfig(self) -> "DoIpConfig":
        """
        AUTOSAR-compliant getter for doIpConfig.
        
        Returns:
            The doIpConfig value
        
        Note:
            Delegates to do_ip_config property (CODING_RULE_V2_00017)
        """
        return self.do_ip_config  # Delegates to property

    def setDoIpConfig(self, value: "DoIpConfig") -> "EcuInstance":
        """
        AUTOSAR-compliant setter for doIpConfig with method chaining.
        
        Args:
            value: The doIpConfig to set
        
        Returns:
            self for method chaining
        
        Note:
            Delegates to do_ip_config property setter (gets validation automatically)
        """
        self.do_ip_config = value  # Delegates to property setter
        return self

    def getEcuTaskProxy(self) -> List["OsTaskProxy"]:
        """
        AUTOSAR-compliant getter for ecuTaskProxy.
        
        Returns:
            The ecuTaskProxy value
        
        Note:
            Delegates to ecu_task_proxy property (CODING_RULE_V2_00017)
        """
        return self.ecu_task_proxy  # Delegates to property

    def getEthSwitchPort(self) -> "Boolean":
        """
        AUTOSAR-compliant getter for ethSwitchPort.
        
        Returns:
            The ethSwitchPort value
        
        Note:
            Delegates to eth_switch_port property (CODING_RULE_V2_00017)
        """
        return self.eth_switch_port  # Delegates to property

    def setEthSwitchPort(self, value: "Boolean") -> "EcuInstance":
        """
        AUTOSAR-compliant setter for ethSwitchPort with method chaining.
        
        Args:
            value: The ethSwitchPort to set
        
        Returns:
            self for method chaining
        
        Note:
            Delegates to eth_switch_port property setter (gets validation automatically)
        """
        self.eth_switch_port = value  # Delegates to property setter
        return self

    def getFirewallRule(self) -> List["StateDependentFirewall"]:
        """
        AUTOSAR-compliant getter for firewallRule.
        
        Returns:
            The firewallRule value
        
        Note:
            Delegates to firewall_rule property (CODING_RULE_V2_00017)
        """
        return self.firewall_rule  # Delegates to property

    def getPartition(self) -> List["EcuPartition"]:
        """
        AUTOSAR-compliant getter for partition.
        
        Returns:
            The partition value
        
        Note:
            Delegates to partition property (CODING_RULE_V2_00017)
        """
        return self.partition  # Delegates to property

    def getPncNmRequest(self) -> "Boolean":
        """
        AUTOSAR-compliant getter for pncNmRequest.
        
        Returns:
            The pncNmRequest value
        
        Note:
            Delegates to pnc_nm_request property (CODING_RULE_V2_00017)
        """
        return self.pnc_nm_request  # Delegates to property

    def setPncNmRequest(self, value: "Boolean") -> "EcuInstance":
        """
        AUTOSAR-compliant setter for pncNmRequest with method chaining.
        
        Args:
            value: The pncNmRequest to set
        
        Returns:
            self for method chaining
        
        Note:
            Delegates to pnc_nm_request property setter (gets validation automatically)
        """
        self.pnc_nm_request = value  # Delegates to property setter
        return self

    def getPncPrepare(self) -> "TimeValue":
        """
        AUTOSAR-compliant getter for pncPrepare.
        
        Returns:
            The pncPrepare value
        
        Note:
            Delegates to pnc_prepare property (CODING_RULE_V2_00017)
        """
        return self.pnc_prepare  # Delegates to property

    def setPncPrepare(self, value: "TimeValue") -> "EcuInstance":
        """
        AUTOSAR-compliant setter for pncPrepare with method chaining.
        
        Args:
            value: The pncPrepare to set
        
        Returns:
            self for method chaining
        
        Note:
            Delegates to pnc_prepare property setter (gets validation automatically)
        """
        self.pnc_prepare = value  # Delegates to property setter
        return self

    def getPnc(self) -> "Boolean":
        """
        AUTOSAR-compliant getter for pnc.
        
        Returns:
            The pnc value
        
        Note:
            Delegates to pnc property (CODING_RULE_V2_00017)
        """
        return self.pnc  # Delegates to property

    def setPnc(self, value: "Boolean") -> "EcuInstance":
        """
        AUTOSAR-compliant setter for pnc with method chaining.
        
        Args:
            value: The pnc to set
        
        Returns:
            self for method chaining
        
        Note:
            Delegates to pnc property setter (gets validation automatically)
        """
        self.pnc = value  # Delegates to property setter
        return self

    def getPnResetTime(self) -> "TimeValue":
        """
        AUTOSAR-compliant getter for pnResetTime.
        
        Returns:
            The pnResetTime value
        
        Note:
            Delegates to pn_reset_time property (CODING_RULE_V2_00017)
        """
        return self.pn_reset_time  # Delegates to property

    def setPnResetTime(self, value: "TimeValue") -> "EcuInstance":
        """
        AUTOSAR-compliant setter for pnResetTime with method chaining.
        
        Args:
            value: The pnResetTime to set
        
        Returns:
            self for method chaining
        
        Note:
            Delegates to pn_reset_time property setter (gets validation automatically)
        """
        self.pn_reset_time = value  # Delegates to property setter
        return self

    def getSleepMode(self) -> "Boolean":
        """
        AUTOSAR-compliant getter for sleepMode.
        
        Returns:
            The sleepMode value
        
        Note:
            Delegates to sleep_mode property (CODING_RULE_V2_00017)
        """
        return self.sleep_mode  # Delegates to property

    def setSleepMode(self, value: "Boolean") -> "EcuInstance":
        """
        AUTOSAR-compliant setter for sleepMode with method chaining.
        
        Args:
            value: The sleepMode to set
        
        Returns:
            self for method chaining
        
        Note:
            Delegates to sleep_mode property setter (gets validation automatically)
        """
        self.sleep_mode = value  # Delegates to property setter
        return self

    def getTcpIpIcmpProps(self) -> "EthTcpIpIcmpProps":
        """
        AUTOSAR-compliant getter for tcpIpIcmpProps.
        
        Returns:
            The tcpIpIcmpProps value
        
        Note:
            Delegates to tcp_ip_icmp_props property (CODING_RULE_V2_00017)
        """
        return self.tcp_ip_icmp_props  # Delegates to property

    def setTcpIpIcmpProps(self, value: "EthTcpIpIcmpProps") -> "EcuInstance":
        """
        AUTOSAR-compliant setter for tcpIpIcmpProps with method chaining.
        
        Args:
            value: The tcpIpIcmpProps to set
        
        Returns:
            self for method chaining
        
        Note:
            Delegates to tcp_ip_icmp_props property setter (gets validation automatically)
        """
        self.tcp_ip_icmp_props = value  # Delegates to property setter
        return self

    def getTcpIpProps(self) -> "EthTcpIpProps":
        """
        AUTOSAR-compliant getter for tcpIpProps.
        
        Returns:
            The tcpIpProps value
        
        Note:
            Delegates to tcp_ip_props property (CODING_RULE_V2_00017)
        """
        return self.tcp_ip_props  # Delegates to property

    def setTcpIpProps(self, value: "EthTcpIpProps") -> "EcuInstance":
        """
        AUTOSAR-compliant setter for tcpIpProps with method chaining.
        
        Args:
            value: The tcpIpProps to set
        
        Returns:
            self for method chaining
        
        Note:
            Delegates to tcp_ip_props property setter (gets validation automatically)
        """
        self.tcp_ip_props = value  # Delegates to property setter
        return self

    def getV2xSupported(self) -> "V2xSupportEnum":
        """
        AUTOSAR-compliant getter for v2xSupported.
        
        Returns:
            The v2xSupported value
        
        Note:
            Delegates to v2x_supported property (CODING_RULE_V2_00017)
        """
        return self.v2x_supported  # Delegates to property

    def setV2xSupported(self, value: "V2xSupportEnum") -> "EcuInstance":
        """
        AUTOSAR-compliant setter for v2xSupported with method chaining.
        
        Args:
            value: The v2xSupported to set
        
        Returns:
            self for method chaining
        
        Note:
            Delegates to v2x_supported property setter (gets validation automatically)
        """
        self.v2x_supported = value  # Delegates to property setter
        return self

    def getWakeUpOverBusSupported(self) -> "Boolean":
        """
        AUTOSAR-compliant getter for wakeUpOverBusSupported.
        
        Returns:
            The wakeUpOverBusSupported value
        
        Note:
            Delegates to wake_up_over_bus_supported property (CODING_RULE_V2_00017)
        """
        return self.wake_up_over_bus_supported  # Delegates to property

    def setWakeUpOverBusSupported(self, value: "Boolean") -> "EcuInstance":
        """
        AUTOSAR-compliant setter for wakeUpOverBusSupported with method chaining.
        
        Args:
            value: The wakeUpOverBusSupported to set
        
        Returns:
            self for method chaining
        
        Note:
            Delegates to wake_up_over_bus_supported property setter (gets validation automatically)
        """
        self.wake_up_over_bus_supported = value  # Delegates to property setter
        return self

    # ===== Fluent with_ methods (CODING_RULE_V2_00019) =====

    def with_channel(self, value: Optional["Boolean"]) -> "EcuInstance":
        """
        Set channel and return self for chaining.
        
        Args:
            value: The channel to set
        
        Returns:
            self for method chaining
        
        Example:
            >>> obj.with_channel("value")
        """
        self.channel = value  # Use property setter (gets validation)
        return self

    def with_client_id_range(self, value: Optional["ClientIdRange"]) -> "EcuInstance":
        """
        Set clientIdRange and return self for chaining.
        
        Args:
            value: The clientIdRange to set
        
        Returns:
            self for method chaining
        
        Example:
            >>> obj.with_client_id_range("value")
        """
        self.client_id_range = value  # Use property setter (gets validation)
        return self

    def with_com(self, value: Optional["TimeValue"]) -> "EcuInstance":
        """
        Set com and return self for chaining.
        
        Args:
            value: The com to set
        
        Returns:
            self for method chaining
        
        Example:
            >>> obj.with_com("value")
        """
        self.com = value  # Use property setter (gets validation)
        return self

    def with_com_enable(self, value: Optional["Boolean"]) -> "EcuInstance":
        """
        Set comEnable and return self for chaining.
        
        Args:
            value: The comEnable to set
        
        Returns:
            self for method chaining
        
        Example:
            >>> obj.with_com_enable("value")
        """
        self.com_enable = value  # Use property setter (gets validation)
        return self

    def with_dlt_config(self, value: Optional["DltConfig"]) -> "EcuInstance":
        """
        Set dltConfig and return self for chaining.
        
        Args:
            value: The dltConfig to set
        
        Returns:
            self for method chaining
        
        Example:
            >>> obj.with_dlt_config("value")
        """
        self.dlt_config = value  # Use property setter (gets validation)
        return self

    def with_do_ip_config(self, value: Optional["DoIpConfig"]) -> "EcuInstance":
        """
        Set doIpConfig and return self for chaining.
        
        Args:
            value: The doIpConfig to set
        
        Returns:
            self for method chaining
        
        Example:
            >>> obj.with_do_ip_config("value")
        """
        self.do_ip_config = value  # Use property setter (gets validation)
        return self

    def with_eth_switch_port(self, value: Optional["Boolean"]) -> "EcuInstance":
        """
        Set ethSwitchPort and return self for chaining.
        
        Args:
            value: The ethSwitchPort to set
        
        Returns:
            self for method chaining
        
        Example:
            >>> obj.with_eth_switch_port("value")
        """
        self.eth_switch_port = value  # Use property setter (gets validation)
        return self

    def with_pnc_nm_request(self, value: Optional["Boolean"]) -> "EcuInstance":
        """
        Set pncNmRequest and return self for chaining.
        
        Args:
            value: The pncNmRequest to set
        
        Returns:
            self for method chaining
        
        Example:
            >>> obj.with_pnc_nm_request("value")
        """
        self.pnc_nm_request = value  # Use property setter (gets validation)
        return self

    def with_pnc_prepare(self, value: Optional["TimeValue"]) -> "EcuInstance":
        """
        Set pncPrepare and return self for chaining.
        
        Args:
            value: The pncPrepare to set
        
        Returns:
            self for method chaining
        
        Example:
            >>> obj.with_pnc_prepare("value")
        """
        self.pnc_prepare = value  # Use property setter (gets validation)
        return self

    def with_pnc(self, value: Optional["Boolean"]) -> "EcuInstance":
        """
        Set pnc and return self for chaining.
        
        Args:
            value: The pnc to set
        
        Returns:
            self for method chaining
        
        Example:
            >>> obj.with_pnc("value")
        """
        self.pnc = value  # Use property setter (gets validation)
        return self

    def with_pn_reset_time(self, value: Optional["TimeValue"]) -> "EcuInstance":
        """
        Set pnResetTime and return self for chaining.
        
        Args:
            value: The pnResetTime to set
        
        Returns:
            self for method chaining
        
        Example:
            >>> obj.with_pn_reset_time("value")
        """
        self.pn_reset_time = value  # Use property setter (gets validation)
        return self

    def with_sleep_mode(self, value: Optional["Boolean"]) -> "EcuInstance":
        """
        Set sleepMode and return self for chaining.
        
        Args:
            value: The sleepMode to set
        
        Returns:
            self for method chaining
        
        Example:
            >>> obj.with_sleep_mode("value")
        """
        self.sleep_mode = value  # Use property setter (gets validation)
        return self

    def with_tcp_ip_icmp_props(self, value: Optional["EthTcpIpIcmpProps"]) -> "EcuInstance":
        """
        Set tcpIpIcmpProps and return self for chaining.
        
        Args:
            value: The tcpIpIcmpProps to set
        
        Returns:
            self for method chaining
        
        Example:
            >>> obj.with_tcp_ip_icmp_props("value")
        """
        self.tcp_ip_icmp_props = value  # Use property setter (gets validation)
        return self

    def with_tcp_ip_props(self, value: Optional["EthTcpIpProps"]) -> "EcuInstance":
        """
        Set tcpIpProps and return self for chaining.
        
        Args:
            value: The tcpIpProps to set
        
        Returns:
            self for method chaining
        
        Example:
            >>> obj.with_tcp_ip_props("value")
        """
        self.tcp_ip_props = value  # Use property setter (gets validation)
        return self

    def with_v2x_supported(self, value: Optional["V2xSupportEnum"]) -> "EcuInstance":
        """
        Set v2xSupported and return self for chaining.
        
        Args:
            value: The v2xSupported to set
        
        Returns:
            self for method chaining
        
        Example:
            >>> obj.with_v2x_supported("value")
        """
        self.v2x_supported = value  # Use property setter (gets validation)
        return self

    def with_wake_up_over_bus_supported(self, value: Optional["Boolean"]) -> "EcuInstance":
        """
        Set wakeUpOverBusSupported and return self for chaining.
        
        Args:
            value: The wakeUpOverBusSupported to set
        
        Returns:
            self for method chaining
        
        Example:
            >>> obj.with_wake_up_over_bus_supported("value")
        """
        self.wake_up_over_bus_supported = value  # Use property setter (gets validation)
        return self